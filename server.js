import { WebSocketServer, WebSocket } from 'ws';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import { MongoClient, ServerApiVersion } from 'mongodb'; // Import MongoClient

// --- Define __dirname for ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- Configuration ---
const PORT = process.env.PORT || 3000;
// Use environment variable for connection string (recommended for deployment)
// Fallback to hardcoded string for local testing ONLY (replace with your actual password if testing locally)
const MONGODB_URI = process.env.MONGODB_URI || "mongodb+srv://Azurely:<Azurely12123>@gcchat.aqgwni3.mongodb.net/?retryWrites=true&w=majority&appName=gcCHAT";
const DB_NAME = 'gcCHAT'; // Your database name
const COLLECTION_NAME = 'messages'; // Collection to store messages

// --- State ---
let clients = new Set();
let db; // Database connection object
let messagesCollection; // Database collection object

// --- MongoDB Connection ---
async function connectDB() {
    if (!MONGODB_URI || MONGODB_URI.includes("<password>") || MONGODB_URI.includes("<yuh>")) {
        console.error("[Server] ERROR: MongoDB connection string is missing, invalid, or contains a placeholder password.");
        console.error("[Server] Please set the MONGODB_URI environment variable with your actual connection string.");
        process.exit(1); // Exit if connection string is invalid
    }
    try {
        const client = new MongoClient(MONGODB_URI, {
            serverApi: {
                version: ServerApiVersion.v1,
                strict: true,
                deprecationErrors: true,
            }
        });
        await client.connect();
        db = client.db(DB_NAME);
        messagesCollection = db.collection(COLLECTION_NAME);
        console.log("[Server] Successfully connected to MongoDB Atlas!");
        // Optional: Create index for faster timestamp sorting
        await messagesCollection.createIndex({ timestamp: 1 });
    } catch (error) {
        console.error("[Server] Failed to connect to MongoDB:", error);
        process.exit(1); // Exit if connection fails
    }
}

// --- History Handling (Now uses DB) ---
async function loadHistoryFromDB() {
    if (!messagesCollection) {
        console.error("[Server] Cannot load history, database not connected.");
        return [];
    }
    try {
        // Load recent messages, e.g., last 100, sorted by timestamp
        const history = await messagesCollection.find()
            .sort({ timestamp: -1 }) // Sort descending (newest first)
            .limit(100) // Limit the number of messages loaded initially
            .toArray();
        console.log(`[Server] Loaded ${history.length} messages from database.`);
        return history.reverse(); // Reverse to show oldest first in chat
    } catch (error) {
        console.error("[Server] Error loading history from database:", error);
        return [];
    }
}

async function saveMessageToDB(messageData) {
    if (!messagesCollection) {
        console.error("[Server] Cannot save message, database not connected.");
        return;
    }
    try {
        // Insert the new message document
        await messagesCollection.insertOne(messageData);
        // console.log("[Server] Message saved to database.");
    } catch (error) {
        console.error("[Server] Error saving message to database:", error);
    }
}

// --- Broadcast Logic ---
function broadcast(message) { // Sender parameter no longer needed here
  const messageString = JSON.stringify(message);
  clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(messageString);
    }
  });
}

// --- Server Setup ---
async function startServer() {
    await connectDB(); // Connect to DB first
    const initialHistory = await loadHistoryFromDB(); // Load initial history

    const server = new WebSocketServer({ port: PORT });

    server.on('listening', () => {
        console.log(`[Server] WebSocket server started and listening on port ${PORT}`);
    });

    server.on('connection', (ws, req) => {
        const clientIdentifier = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
        console.log(`[Server] Client connected: ${clientIdentifier}`);
        clients.add(ws);

        // Send initial history (loaded once at server start)
        ws.send(JSON.stringify({ type: 'history', payload: initialHistory }));

        ws.on('message', async (message) => { // Make handler async for DB operations
            try {
                const parsedMessage = JSON.parse(message);
                console.log('[Server] Received:', parsedMessage);

                if (parsedMessage.type === 'chat' && parsedMessage.text && parsedMessage.sender) {
                    const messageData = {
                        // _id will be generated by MongoDB automatically
                        type: 'chat', // Keep type for client handling
                        id: parsedMessage.id || `${Date.now()}-${Math.random().toString(36).substring(7)}`, // Keep for potential client-side use? Or remove?
                        text: parsedMessage.text,
                        sender: parsedMessage.sender,
                        timestamp: parsedMessage.timestamp || Date.now()
                    };
                    await saveMessageToDB(messageData); // Save to DB
                    broadcast(messageData); // Broadcast the message (don't include _id?)
                } else {
                    console.warn('[Server] Received invalid chat message format:', parsedMessage);
                }
            } catch (e) {
                console.error('[Server] Failed to parse message or process:', message.toString(), e);
            }
        });

        ws.on('close', () => {
            console.log(`[Server] Client disconnected: ${clientIdentifier}`);
            clients.delete(ws);
        });

        ws.on('error', (error) => {
            console.error(`[Server] WebSocket error for client ${clientIdentifier}:`, error);
            clients.delete(ws);
        });
    });

    server.on('error', (error) => {
        console.error('[Server] WebSocket Server Error:', error);
        if (error.code === 'EADDRINUSE') {
            console.error(`[Server] Port ${PORT} is already in use.`);
            process.exit(1);
        }
    });

    // Graceful shutdown
    process.on('SIGINT', async () => {
        console.log('[Server] Shutting down...');
        // Close DB connection? MongoClient handles pooling, maybe not needed to explicitly close here? Check driver docs.
        // Let's assume client.close() is needed if we stored the client instance. Since we only store db/collection, maybe it's okay.
        server.close(() => {
            console.log('[Server] WebSocket server closed.');
            // Consider closing MongoDB client here if necessary: client.close();
            process.exit(0);
        });
        setTimeout(() => {
            console.log('[Server] Forcing remaining connections closed.');
            clients.forEach(client => client.terminate());
            process.exit(1);
        }, 3000); // Increased timeout slightly
    });
}

// --- Start the Server ---
startServer();
